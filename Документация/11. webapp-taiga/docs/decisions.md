# Принятые решения

- Верстка является адаптивной, но контент не состоит из одних и тех же элементов (дизайн предполагает разный контент для разных устройств, различное текстовое содержание, различный порядок блоков). Для того, чтобы это было справедливо и для SSR (чтобы страница до загрузки JS отображалась корректно), было решено рендерить все варианты контента, скрывая их медиазапросами. Это было сделано на поводу у двух идей: 1) разнообразный дизайн 2) SSR для SEO. Это было неверное решение - от него страдает поддерживаемость кода. Чтобы от него отказаться, нужно избавиться от планшетной версии, а оставшееся разделить на отдельную десктопную и отдельную мобильную версии.

- Приложение содержит немало закомментированного кода. Это следствие того, что вначале планировали всё сверстать, а потом заставить работать всё сразу. Это была плохая идея.

- Мы не используем `emotion`, потому что он иногда даёт непредсказуемые результаты при сервер-сайд рендере в dev-режиме. Очевидно, предсказуемость важнее удобств, поэтому мы отказались от `emotion` и перешли на `SCSS`. Если будет хотеться поиспользовать styled-компоненты или какой-нибудь другой css-in-js, то следует помнить, что рендер может различаться в SSR на dev, SSR на prod и в браузере. Возможно, перехочется.

- Docker build context указывает на `platform` потому что мы хотим использовать схему graphql, общую для всех, и `webapp-taiga` не подходит для build context.

- `typescript` и всё, относящееся к нему, живёт в `dependencies` , а не в `devDependencies` , потому что ts используется в рантайме для ssr. А вот библиотеки для линтинга и тестов должны быть в `devDependencies`.

- Next.js не требует `import React from 'react';` , но мы добавляем его ради с `ts-jest` . Если этого не делать, то придётся хакать решение с Babel, но такие хаки со временем "сами перестают работать", поэтому просто импортируем реакт и с Babel не связываемся. Можно также почитать [issue 1308 в ts-jest](https://github.com/kulshekhar/ts-jest/issues/1308).

- Отображать даты требуется не только на клиенте, но и при SSR. Это требует наличия таймзоны, и при SSR данных о ней нет. Исходя из предположения, что портал будет разворачиваться для нескольких городов, и это могут быть разные инстансы webapp, решено передавать IANA-таймзону в ENV. Для новосибирского сайта по умолчанию будет использоваться новосибирская таймзона, для московского - московская, а для браузеров, до которых уже доехал JS код - та таймзона, которая установлена в браузере.

- Для того, чтобы при SSR форматировать время с учётом локали (отображать название месяца русскими буквами), требуется объект `Intl`, которого нет Node до версии 14, и вместо использования полифилла мы используем **Node 14 (LTS)**. В ней требуемый объект присутствует. (Если в тестах без докера не работает локаль, то нужно убедиться, что локальная версия node соответствует `.nvmrc`)

- Для отображения времени в произвольной таймзоне используется библиотека Luxon по двум причинам:

  - она корректно работает на Node и проходит тесты, чего нельзя сказать про `date-fns` (`date-fns-tz`) и `spacetime`;
  - она использует иммутабельные данные.

- Вебапп не отвечает кодом HTTP 500 в тех случаях, если запрос к серверу при SSR был выполнен с ошибкой. Вместо этого он отобрражает полноценный UI, а ошибка выводится на странице отдельным блоком. Это позволяет реализовать отображение интерфейса, в котором не все элементы блокируются. Поэтому `getServerSideProps` никогда не должен быть rejected, и должен возвращать данные в таком виде:

```typescript
Promise<{
  props: {
    [propName: string]: Either<string, PropType>
  }
}>
```

- `storyshots` не используем, потому что неудобно конфигурировать и неочевидно, что делать при падении теста. Проще использовать Jest и не смешивать всё в кучу. Stories не подкрепляют типобезопасность, так что рассчитывать на них в тестах - плохая идея.

- В GraphQL-запросах фрагменты содержат префикс. Это ограничение продиктовано `graphql-tag`, на который опирается `graphql-codegen`. Это необоснованное ограничение, но оно есть и мы принимаем его как данность. В качестве префикса проще всего использовать имя запроса.

## Поисковые формы

Важно правильно проводить `trust boundary` - границу, за которой данные считаются некорректными (следовательно, парсятся/валидируются), а внутри - корректными (и используются без валидаций). Признаком верно определённого `trust boundary` является отсутствие `null`, `undefined` и исключений в бизнес-логике.

В данном приложении внешние данные (пользовательский ввод и query params) валидируются не предикатами (т.е. функциями `string -> boolean`) а функциями `string -> Either<errorMessage, A>`, где `A` - целевой тип, значение которого будет декодировано из строкового предствления, а `errorMessage` - строка с сообщением о причине неудачи. Такой подход позволяет не отделять валидацию строк от приведения строк к нужному типу, а вместо этого сразу пытаться конструировать значение нужного типа, учитывая возможность неудачи.

Для единообразия рекомендуется в каждой форме именовать типы состояний и функции одинаково.

![search form validation](Документация/11.%20webapp-taiga/docs/assets/validations.svg)

**Параметры выборки** - это фильтрация, пагинация и сортировка.

### query string

Строка с параметрами выборки, является частью URL. Данным из неё мы не доверяем. Она должна автоматически изменяться по мере изменения значений на форме. Будет использоваться в sitemaps для SEO. Мы специально не полагаемся целиком на механизм роутинга, предоставленный Next, чтобы иметь возможность манипулировать этой строкой произвольным образом.

### Query Object

Параметры выборки, представленные в виде объекта, где ключи и значения - это строки, а также в нём не поддерживается вложенность полей. Данным из него мы тоже не доверяем, но знаем, что это точно объект, и что его значения - точно строки.

- Next.js декодирует из `query string` в `Query Object` самостоятельно (включит всё, что сможет, поэтому вcе поля объявлены как nullable).
- Обратно преобразование производится функцией `toQueryString`, которая использует библиотеку `query-string`.

### Form State

Состояние формы, которое содержит данные о корректности значений отдельных полей. Данные каждого поля - это `FormField<A>`, в котором содержится как строковое представление, так и `Either<string, A>` (результат конструирования и валидации). Это состояние формы содержит все параметры выборки, которые только можно задать.

- функция `fromQueryObject` должна всегда заполнять `FormState` валидными значениями `FormField`, декодируя из строк и заменяя невалидные значения полей значениями по умолчанию
- функция `toQueryObject` включает в `QueryObject` значения только валидных полей. При этом если значение является значением по умолчанию, то оно также исключается.

### Graphql Inputs

В поисковой форме этот тип соответствует согласованному набору параметров выборки. За согласованность отвечает `fromQueryObject` и редюсер, используемый для полей формы. Разрешение конфликтов полей формы без участия пользователя делает ненужной обратную связь всей формы.
