## Принятые решения и конвенции

* Таймстампы (значения полей DateTime) передаём фронту в секундах так как тип Int в GraphQL ограничен 32 битами.

* Некоторые данные храним непосредственно в коде, а не в таблице (см. `server-realty/server_realty/data_mapping`):
    - данные о валютах

* Для реализации jwt-аутентификации присвоили код из библиотеки django-ariadne-jwt, т.к. её больше не поддерживают

* Поскольку у нас много сервисов, которые содержат в себе весь код бэка django, но запускаются с разными entrypoints (
  server-realty-beat, server-realty-worker), мы билдим сервис server-realty-base, который не делает ничего сам по себе,
  но является основой для всех остальных

* У нас есть отдельные сервисы в контейнерах которые зависят от дб и требуют чтобы там прошли все миграции. На данном
  этапе миграции производятся только в сервисе `server-realty`, а во всех остальных ожидаем успешного завершения
  миграций через shell-скрипт. Пример кода скрипта есть в `server-realty/entrypoint_scripts/run_beat.sh`

* При создании/обновлении офферов из фида вручную добавляем таймстэмпы в поля created_in_db и/или updated_in_db, это
  связано с тем, что auto_now и auto_now_add не работают с балком

* Модель базы данных BuildingInfo содержит различную информацию о здании, начиная от адреса и планируемой даты окончания
  строительства заканчивая наличием парковки. В случае размещения объявления о продаже квартиры в одном и том же здании
  разными организациями, существует вероятность, что предоставленная разными организациями информация может отличаться (
  банально, одна организация может указать наличие парковки, а другая нет). Для исключения недоразумений, если данные о
  здании у одной организации отличаются от данных другой - создается новая запись в БД, то есть фактически данные о
  здании будут задублированы за исключением различающихся полей. В ЖК (Жилищном комплексе, Housing Complex)
  отображаются данные о здании (BuildingInfo) из фида (Feed) той организации, которая создала ЖК.

### Тестирование

* Внешние зависимости которые всегда нужно мокать мокаются в `runtests.py`

### Источники правды данных

* Ближайшее метро - дадата

### Что нужно делать для совместимости с django-cacheops:

* Минимизировать использование `bulk_update()`
    * почему: `bulk_update()` не посылает сигналы и следовательно не триггерит инвалидацию кэша
    * когда без функционала `bulk_update()` никак не обойтись (например в `bulk_sync()`), использовать наш кастомный
      `invalidated_bulk_update()`, который инвалидирует кэш вручную
* Использовать в QuerySet-ах `.invalidated_update()` вместо `.update()`
    * почему: `.update()` не посылает сигналы и следовательно не триггерит инвалидацию кэша
* При оптимизации запросов в базу использовать `.prefetch_related()` вместо `.select_related()`
    * почему: кэш по запросу который получает данные связанных объектов через `.select_related()` не инвалидируется при
      обновлении одного из этих объектов
* Убрать в `bulk_sync()` использование `.only()`
    * почему: из-за него вылетает очень странный баг, связанный с кэшопсовским monkey-patching. Подробнее здесь:
        * https://github.com/Suor/django-cacheops/issues/348
        * https://github.com/mathandpencil/django-bulk-sync/issues/17
* Явно указывать модели к которым применяем кэширование в настройках cacheops в `settings.py`
    * почему: мы не хотим чтобы кэшировались всякие сервисные вещи (вроде PeriodicTask)
* Писать юнит-тесты с использованием кастомного класса `RealtyServerTestCase`
    * изоляция в обычном `django.test.TestCase` реализована через заворот теста в транзакцию и откат её после окончания
      работы. Нам не подходит такое решение, т.к. cacheops выключает кэширование при старте транзакции, а все
      инвалидации откладывает до её коммита. `RealtyServerTestCase` наследуется от `django.test.TransactionTestCase`, в
      котором откат базы до исходного состояния реализован по-другому. Подробности здесь:
        * https://github.com/Suor/django-cacheops#transactions
        * https://docs.djangoproject.com/en/3.0/topics/testing/tools/#transactiontestcase
    * в `RealtyServerTestCase` реализован вовзрат кэша к исходному состоянию для каждого теста
* Помнить, что cacheops кэширует не все методы ORM даже если мы указали в настройках `'all'`
    * `'all'` покрывает только `.get`, `.fetch`, `.count`, `.aggregate` и `.exists`
    * это особенно важно в тестах - может быть так что в кэше у нас неверные значения, но мы этого не замечаем,
      поскольку делаем assert напрямую с базой минуя кэш (например, через `.values_list`)

### Настройки дев-окружения

Все секреты, которые, в том числе, требуются для разработки - хранятся в HashiCorp Vault. Для настроки окружения в
режиме разработки переопределяется файл настроек с `settings.py` на `settings_dev.py`, который:

* устанавливает несекретные настройки из файла `base_dev_settings.env`(в режиме локальной разработки), а также
  переопределяет настройки из `container_dev_settings.env` (в случае запуска приложения в контейнере)

* получает секреты из hashicorp vault и устанавливает их в переменные окружения

* импортирует настройки из основного `settings.py`

Используемая в проекте библиотека [Django-environ](https://django-environ.readthedocs.io/) по умолчанию не
перезаписывает настройки, если они были определены ранее.

В режиме разработки мы используем отдельный Redis расположенный в Облаке для хранения кэшей запросов к сервису Dadata.
Также запускается локальный Redis для хранения данных Cacheops, очередей Celery и т.п.
