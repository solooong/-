# To Do list

**Выделеные задачи** имеют больший приоритет

### Общие задачи по бэку

* **Ловить ситуацию когда нет доступа к redis (сейчас сервер просто виснет)**

* Организовать на этапе CI проверку на соответствие сгенерированных миграций моделям

* Реализовать разрешения (django-rules)

* Расширить функционал отправки логов в logz.io (json/отдельные поля)

* Реализовать инвалидацию кэша для dadata (когда будем решать это проблему надо будет помнить про то что мы сейчас
  используем ещё и lru_cache)

### Инфраструктура

* --

### Модели и база данных

* Решить проблему поиска, сортировки, фильтрации и пагинации по нескольким моделям сразу. Возможные пути решения:
    * [django-polymorphic](https://github.com/django-polymorphic/django-polymorphic)
    * [django-querysetsequence](https://github.com/percipient/django-querysetsequence)
    * stored procedures

* **Сейчас garbage collection инициализируется в wsgi.py, возможно при использовании gunicorn на проде это не будет
  стрелять. И вообще, хотелось бы делать это не при запуске сервера, а где-то раньше при деплое.**

* Реструктурировать связь объявлений с фидом - сделать более абстрактный OfferDataSource, который помимо ссылок на фид
  сможет также поддерживать добавление объявлений вручную или через api (в этих ситуациях будет другая логика
  добавления, обновления и удаления).

### Эндпойнт GraphQL

* Вынести graphql в отдельное приложение джанго

* Читнуть про Scalar DateTime

* Подробнее изучить специфику jwt (сейчас оно в базовом варианте)

* нормальный синглтон для инстансов type definition

### Фиды и объявленя

* **Использовать датакласс вместо unique factory.**
  Принцип работы: при проверке уникальности данных фабрика уникальных создает словарь, ключами которого являются
  кортежи (tuple)
  из набора аргументов для создания инстанса модели (т.е. значения её полей), а значениями являются собственно инстансы
  моделей. Соответственно, если мы раньше уже создавали инстанс с данными значениями то в словаре уже присутствует этот
  ключ и unique_factory может вернуть ранее созданный инстанс вместо того чтобы создавать новый Проблема: Если одно из
  полей модели A является foreign key на модель B, то мы подаём в наборе исходных аргументов для A несохраненный инстанс
  B. Поскольку инстанс B является частью кортежа аргументов - он хэшируется. Django не позволяет хэшировать
  несохраненные инстансы моделей и мы получаем ошибку. Потенциальное решение: не трансформировать набор аргументов в
  инстанс модели сразу же после проверки на уникальность, а делать это в самом конце, непосредственно перед
  вызовом `bulk_sync`

* Держать данные по метро в нашей базе, а не дёргать из дадаты

* Проблемы связанные с локацией зданий (решать через postgis?)
    * Нужно брать близлежащие метро из фида когда их нет в дадате (если здание строится), либо найти альтернативный
      источник информации
    * Нужно решать проблему двойных адресов - записывать их при сохранении, обеспечивать поиск на всех уровнях (улица,
      дом)
    * Проблема микрорайонов - иногда микрорайон играет роль улицы, а иногда он содержит улицы внутри себя - во второй
      ситуации мы знаем только улицу, но не знаем что она часть микрорайона

* Если дом находится в стадии строительства, то его еще нет в ФИАСе, соответственно дадата в поле house_fias_id
  возвращает Null. Мы решили сделать поле house_fias_id в БД nullable, надо решить что с этим делать дальше. Как
  вариант:
  вносить адреса новых домов ручками, а если приходит оффер, адрес которого не найден в дадате и он не внесен вручную -
  скипаем его и пишем ошибку (в таком случае надо решить что пишем в house_fias_id и как часто инвалидируем кэш запросов
  к дадате на предмет "а не появился данный адрес в фиасе")

* Модерация / проверка текста объявлений

### Изображения и object storage

* Сделать тест на то что сохраняется порядок изображений указанный в фиде

* Чтобы каждый раз не ресайзить изображения при повторной их загрузке - вместо моментального удаления изображений
  помещаем их в холодное хранилище с ограниченным сроком жизни (месяц, два, пол года) и при каждой последующей загрузке
  изображений проверяем, есть ли изображение в холодном хранилище и если есть - вытаскиваем его из холодного в
  стандартное

* Если url картинки слишком длинный, то картинка не сохраняется - проверить на каком этапе вываливается ошибка: на этапе
  создания модели или на этапе записи в БД. Написать тест

* Надо понять из каких форматов мы конвертим картинки и добавить недостающие

* Валидация / модерация изображений: проверяем что на картинке не какой-нибудь запрещенный контент

* Добавить логи с информацией о формате сконверченной картинки.

* Переделать конвертацию изображений, что бы альфа-канал не терялся, если он есть у изображения. То есть png должны
  конвертиться в png: что бы у логотипа оставался прозрачный фон, а не белый прямоугольник как это реализовано сейчас.

### Celery

* Почитать про celery broker_failover_strategy и внести изменения в настройки, если недо

* Решить проблему скейлинга воркеров (сделать апи для яндекса?)

* Решить проблему с падением redis при передаче в таску аргумента с большим объемом. Подозреваем, что дело в косяке в
  kombu при взаимодействии с сокетами ([детали](https://github.com/celery/celery/issues/318))

* Починить flower, сделать так, чтобы он работал с облачными окружениями, написать доки
